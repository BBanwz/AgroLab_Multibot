Нижний уровень
--------------

Этот код написан для платформы Arduino и использует некоторые дополнительные библиотеки для управления устройством Agrolab multibot с задачами, связанными с перемещением, измерением температуры, влажности и другими функциями. Давайте разберём каждую часть кода:

Подключаемые библиотеки
~~~~~~~~~~~~~~~~~~~~~~~

- ``"RTOS.h"``: библиотека для использования операционной системы реального времени (RTOS) - позволяет системе выполнять многозадачность.

- ``<AccelStepper.h>``: библиотека для управления шаговыми двигателями с акселерацией и декселерацией.

- ``"DHT.h"``: библиотека для работы с датчиками влажности и температуры DHT.

Подключаемые страницы кода
~~~~~~~~~~~~~~~~~~~~~~~~~~

Содержат дополнительные настройки, функции и переменные, используемые в главном скетче.

1. ``"Setup.h"``

Код определяет константы и переменные для различных входных/выходных контактов (пинов) и настроек.

Перечислим некоторые из них:

- Константы, определяющие пины для подключения степперных моторов (X, Y и Z).

- Константы, определения максимальных значений координат (X_MAX, Y_MAX, Z_MAX) для каждого из степперных моторов.

- Определение пинов для датчиков концевых выключателей (X_ENDSTOP1, Y_ENDSTOP1, Z_ENDSTOP1).

- Определение пинов для различных светодиодов (ULED1-4).

- Определение аналоговых пинов для сенсоров (analogPin1, analogPin2, analogPin3).

- Определение пина для чтения показаний влажности почвы (SoilTest).

- Установка связанных с датчиками DHT для измерения температуры и влажности (DHTPIN, DHTTYPE).

- Определение значений ШПУ для различных рабочих операций (DRILL_Z, WATER_Z, FORK_Z, LAZER_Z, COLLECT_Z).

- Установка пинов для управления насосом, захватом, светом и другими дополнительными устройствами.

Определение переменных, таких как:

- force_stop и stopped, используемых для реализации аварийной остановки.

- light_time и light_enabled, связанные с временем работы света.

- serial_command, используется для хранения и анализа команд, получаемых через последовательное соединение.

2. ``"Steppers.h"``

- homeZ(): Функция домашней позиции для оси Z. Степпер-мотор перемещается в отрицательном направлении, пока не достигнет концевого выключателя. Если процесс остановлен, функция возвращает значение 1, иначе 0.

- homeX(): Аналогичная функция домашней позиции для оси X.

- homeY(): Аналогичная функция домашней позиции для оси Y.

- homeALL(): Функция домашней позиции для всех осей (X, Y и Z) одновременно. Процесс остановлен, если функция возвращает значение 1, иначе 0.

- moveZ(int distance): Функция перемещения степпер-мотора по оси Z на заданное расстояние. Функция проверяет допустимость расстояния и адаптирует его при необходимости. Если процесс остановлен, функция возвращает значение 1, иначе 0.

- moveX(int distance): Аналогичная функция перемещения степпер-мотора для оси X.

- moveY(int distance): Аналогичная функция перемещения степпер-мотора для оси Y.

- moveXY(int x, int y): Функция для перемещения степпер-моторов X и Y одновременно на заданные координаты x и y. Функция также проверяет допустимость координат и корректирует их при необходимости. Если процесс остановлен, функция возвращает значение 1, иначе 0.

3. ``"funkSetup.h"``

- Настройка трех шаговых двигателей (stepperX, stepperY, и stepperZ) с заданными максимальной скоростью, текущей скоростью, ускорением и настройкой инвертирования ножек (пинов).

- Установка ножек (пинов) светодиодов (ULED1, ULED2, ULED3, и ULED4) на выход (OUTPUT).

- Установка пина лазера (LAZER) на выход (OUTPUT) и установка его начального значения на 0.

- Установка ножек (пинов) для управления периферийными устройствами (CONTROL_PEREPHERIAL_PIN_SELECT, LIGHT_PIN, и PUMP_PIN) на выход (OUTPUT) и задание начальных значений.

- Установка ножек (пинов) для включения или отключения шаговых двигателей (ENPin1, ENPin2, ENPin3, и ENPin4) на выход (OUTPUT).

- Установка ножек (пинов) шага и направления шаговых двигателей (stepPinX, stepPinY, stepPinZ, dirPinX, dirPinY и dirPinZ) на выход (OUTPUT).

- Установка ножек (пинов) концевых выключателей для каждого из шаговых двигателей (X_ENDSTOP1, Y_ENDSTOP1 и Z_ENDSTOP1) на вход с подтяжкой к питанию (INPUT_PULLUP).

- Установка ножек (пинов) для манипулятора (GRASP_PIN и GRASP_PIN_EN) на выход (OUTPUT).

4. ``"addFunk.h"``

**Функция enOFF**

В этой функции, пины ENPin1, ENPin2, ENPin3 и ENPin4 задаются в состояние HIGH. Это обычно используется для выключения электронных компонентов, подключенных к данным выводам, хотя это зависит от конкретной схемы подключения.

**Функция enON**

В этой функции, пины ENPin1, ENPin2, ENPin3 и ENPin4 задаются в состояние LOW. Это обычно используется для включения электронных компонентов, подключенных к данным выводам, хотя это также зависит от конкретной схемы подключения.

5. ``"work.h"``

Предназначен для управления и тестирования оборудования, использующего шаговые моторы для перемещения по осям X, Y и Z.

Объявление потоков
~~~~~~~~~~~~~~~~~~

Создание двух потоков - один для вывода информации (dataThread), другой для отправления команд в систему (commandsThread).

Функция setup
~~~~~~~~~~~~~

- Запуск серийной связи с скоростью 1000000.

- Инициализация датчика DHT.

- Вызов функции 'funkSetup' для задания начальных значений и настроек.

- Создание потоков и запуск ядра RTOS.

- Функция getValue(): вспомогательная функция для извлечения значения из строки с заданным разделителем на заданной позиции.

Функция data
~~~~~~~~~~~~

Функция потока данных, выводит информацию с датчиков и позицию шаговых двигателей. В случае экстренной остановки ожидает серийное число 666.

Функция commands
~~~~~~~~~~~~~~~~

Функция потока команд, ожидает ввод команд через последовательный монитор. Команды выполняют различные функции, такие как перемещение, управление шаговыми двигателями, использование лазера или насоса и другие. При получении команды "p" и координат x, y, z, программа перемещает двигатели на указанные позиции.

Код реализует управление устройством Agrolab multibot, выполняя различные функции, такие как перемещение, сбор данных, управление светом, насосом, лазером, перемещение и управление шаговыми двигателями.

Код
~~~

::

    //Главная страница программы
    //===========================================================================================
    //Подключаемые библиотеки
    #include "RTOS.h"
    #include <AccelStepper.h>
    #include "DHT.h"
    //============================================================================================
    //подключаемые страницы кода
    #include "Setup.h"
    #include "Steppers.h"
    #include "funkSetup.h"
    #include "addFunk.h"
    #include "work.h"
    //=============================================================================================
    //объявление потоков
    osThreadId thread_0_dataThread;       //поток для вывода информации
    osThreadId thread_0_commandsThread;   //поток для отправления команд в систему
    //==============================================================================================
    void setup() {
      Serial.begin(1000000);
      dht.begin();                        //запуск dht датчика                      
      funkSetup(); 
      /*delay(10000);
      enON();
      homeZ();
      homeY();
      homeX();
    
      moveX(X_MAX/2+500);
      moveY(Y_MAX/2+350);
      moveZ(Z_MAX-250);
      
      use_lazer();
      use_lazer();
      homeZ();
      homeY();
      homeX();
      */
      osThreadDef(DATA_THREAD, data, osPriorityNormal, 0, 1024) ;                  //описывание аргументы потока с данными
      osThreadDef(commandsThread,  commands,  osPriorityNormal, 0, 1024);          //описывание аргументы потока с командами
      
      thread_0_dataThread = osThreadCreate(osThread(DATA_THREAD), NULL);           //создание потока с данными
      thread_0_commandsThread  = osThreadCreate(osThread(commandsThread), NULL);   //создание потока с командами
      
      osKernelStart();   //запуск ядра RTOS для инициализации потоков
    
    }
    
    //=======================================================================
    //Функция создания разделителя для корректного вывода данных
    String getValue(String data, char separator, int index)
    {
        int found = 0;
        int strIndex[] = { 0, -1 };
        int maxIndex = data.length() - 1;
    
        for (int i = 0; i <= maxIndex && found <= index; i++) {
            if (data.charAt(i) == separator || i == maxIndex) {
                found++;
                strIndex[0] = strIndex[1] + 1;
                strIndex[1] = (i == maxIndex) ? i+1 : i;
            }
        }
        return found > index ? data.substring(strIndex[0], strIndex[1]) : "";
    }
    //=======================================================================
    //Функция для потока данных
    static void data(void const *argument)
    {   
      (void) argument;    
        
      for(;;)
        {                     
        Serial.print(stepperX.currentPosition());     //Вывод положения шаговика по Ох
        Serial.print(";");
        Serial.print(stepperY.currentPosition());     //Вывод положения шаговика по Оy
        Serial.print(";");
        Serial.print(stepperZ.currentPosition());     //Вывод положения шаговика по Оz
        Serial.print(";");
        Serial.print(dht.readTemperature());          //Вывод температуры с датчика DHT
        Serial.print(";");
        Serial.print(dht.readHumidity());             //Вывода уровня влажности с датчика DHT
        Serial.print(";");
        Serial.print(map(analogRead(SoilTest), 0, 1023, 0, 100)); //Вывода уровня влажности почвы с резистивного датчика влажности почвы
        Serial.print(";");
        Serial.print(0);                              //Вывод уровня освещённости
        Serial.print(";");
        int PercInt = Perc;
        if (PercInt == 99)
            Perc = 100;
        Serial.println(PercInt);                      //Вывод процента выполненной работы
      
        if (Serial.available())                       //Функция экстренной остановки
          {
            int var = Serial.parseInt();
            if (var==666)
            {
              Perc = -1;
              force_stop=true;
    
              Serial.print(stepperX.currentPosition());     //Вывод положения шаговика по Ох
              Serial.print(";");
              Serial.print(stepperY.currentPosition());     //Вывод положения шаговика по Оy
              Serial.print(";");
              Serial.print(stepperZ.currentPosition());     //Вывод положения шаговика по Оz
              Serial.print(";");
              Serial.print(dht.readTemperature());          //Вывод температуры с датчика DHT
              Serial.print(";");
              Serial.print(dht.readHumidity());             //Вывода уровня влажности с датчика DHT
              Serial.print(";");
              Serial.print(map(analogRead(SoilTest), 0, 1023, 0, 100)); //Вывода уровня влажности почвы с резистивного датчика влажности почвы
              Serial.print(";");
              Serial.print(0);                              //Вывод уровня освещённости
              Serial.print(";");
    //          int PercInt = Perc;
              Serial.println(666);                      //Вывод процента выполненной работы
              Perc = 0;
              
              while(!stopped)
              {
              enOFF();
              
              }
              force_stop=false;
              stopped = false;
            }
          }
          
        osDelay(150);     //задержка потока
        }
    }
    //=======================================================================
    static void commands(void const *argument)
    {
      (void) argument;
      for(;;)
      { 
        /*                      
        if (millis()- light_time > 30000 && light_enabled)
        {
          toggle_light();
          light_enabled=false;
        }
        */
        if (Serial.available())
        {
          serial_command = Serial.readStringUntil('\n');
          if (serial_command[0]=='p' && serial_command[1]==' ')
          {
            String sx,sy,sz;
            sx = getValue(serial_command, ' ', 1);
            sy = getValue(serial_command, ' ', 2);
            sz = getValue(serial_command, ' ', 3);
      
            int x,y,z;
            x = ::atof(sx.c_str());
            y = ::atof(sy.c_str());
            z = ::atof(sz.c_str());
            
            moveX(x);
            moveY(y);
            moveZ(z);
          }
          else
          {
            //возможно понадобится делать отдельный поток, но нужно организовать сброс команды по отдельной команде 
            //int var = Serial.parseInt();
            int var = ::atof(serial_command.c_str());
            switch (var) {
              case 1:
                enON();
                homeALL();
                water();
                Perc = 0;
                break;
              case 2:
                enON();
                homeZ();
                homeY();
                homeX();
                laser();
                Perc = 0;
                break;
              case 3:
                enON();
                homeALL();
                gather();
                Perc = 0;
                break;
              case 4:
                enON();
                homeALL();
                drill();
                Perc = 0;
                break;
              case 5:
                enON();
                homeALL();
                break;
              case 6:
                enOFF();
                break;
              case 7:
                enON();
                break;
              case 8:
                enON();
                homeALL();
                fork();
                Perc = 0;
                break;
              case 9:
                toggle_light();
                break;
              case 10:
                enON();
                homeX();
                break;
              case 11:
                enON();
                homeY();
                break;
              case 12:
                enON();
                homeZ();
                break;
              case 13:
                enON();
                homeALL();
                SeedGather();
                Perc = 0;
                break;
              case 14:
                enON();
                toggle_pump();
                break;
              case 15:
                enON();
                lazer_on();
                break;
              case 16:
                enON();
                lazer_off();
                break;
            }
          }
        }
        osDelay(10); 
      }
    }
    //=======================================================================
